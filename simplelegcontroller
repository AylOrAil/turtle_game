#!/usr/bin/env python3


import rclpy
from miscellaneous import constrain_angle
import numpy as np
from rclpy.node import Node
from control_msgs.action import FollowJointTrajectory
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState, Imu
from nav_msgs.msg import Odometry


class SimpleLegController(Node):
    def __init__(self):
        super().__init__('simple_leg_controller')

        self.declare_parameter('cmd_tau', [0.0] * 6)
        self.declare_parameter('cmd_vel', [0.0] * 6)
        self.declare_parameter('cmd_pos', [0.0] * 6)
        self.declare_parameter('cmd_kp', [0.0] * 6)
        self.declare_parameter('cmd_kd', [0.0] * 6)

        self.publisher = self.create_publisher(Float64MultiArray, '/effort_controller/commands', 10)
        
        self.Odometry_Subscriber_ = self.create_subscription(Odometry, '/odom/robot_pos', self.callback_position, 10)
        self.subJoints_Subscriber_ = self.create_subscription(JointState, '/joint_states', self.callback, 10)
        self.subIMU_Subscriber_ = self.create_subscription(Imu, '/imu/data', self.callback, 10)

        
        self.currPos = np.zeros(6)
        self.currVel = np.zeros(6)
        self.currTorq = np.zeros(6)
        self.currPose = np.zeros(4)
        self.globalPos = np.zeros(3)
        
        self.newdata = False
        self.create_timer(1.0, self.update_parameters)
        self.create_timer(0.1, self.run)  

        self.get_logger().info("SimpleLegController initialized")

    def callback_position(self, msg):
        self.global_pos = np.array([msg.pose.pose.position.x, msg.pose.pose.position.y, msg.pose.pose.position.z])
        self.get_logger().info(f"Position: {self.global_pos}")

    def callback(self,msgJoint: JointState, msgIMU: Imu):
        self.currPos = constrain_angle(np.array([*msgJoint.position]))
        self.currVel = np.array([*msgJoint.velocity])
        self.currTorq = np.array([*msgJoint.effort])
        self.currPose = np.array([msgIMU.orientation.x, msgIMU.orientation.y, msgIMU.orientation.z, msgIMU.orientation.w])

        # Change the leg order so that it matches with the RosNet configuration
        self.currPos = self.currPos[[4, 2, 0, 5, 3, 1]]     
        self.currVel = self.currVel[[4, 2, 0, 5, 3, 1]]
        self.currTorq = self.currTorq[[4, 2, 0, 5, 3, 1]]
        
        self.newdata = True  # Set newdata to True when new data is received


    def update_parameters(self):
        # Update parameters from the parameter server
        cmd_tau = self.get_parameter('cmd_tau').get_parameter_value().double_array_value
        cmd_vel = self.get_parameter('cmd_vel').get_parameter_value().double_array_value
        cmd_pos = self.get_parameter('cmd_pos').get_parameter_value().double_array_value
        cmd_kp = self.get_parameter('cmd_kp').get_parameter_value().double_array_value
        cmd_kd = self.get_parameter('cmd_kd').get_parameter_value().double_array_value
        
        self.get_logger().info(f"cmd_tau: {cmd_tau}")
        self.get_logger().info(f"cmd_vel: {cmd_vel}")
        self.get_logger().info(f"cmd_pos: {cmd_pos}")
        self.get_logger().info(f"cmd_kp: {cmd_kp}")
        self.get_logger().info(f"cmd_kd: {cmd_kd}")
        
        
    def compute_controls(self):
            posErr = (-self.cmd_pos) - self.currPos
            posErr = np.mod(posErr+np.pi, 2*np.pi) - np.pi
            velErr = (-self.cmd_vel) - self.currVel
            commTorque = np.multiply(self.cmd_kp, posErr) + np.multiply(self.cmd_kd, velErr) - self.cmd_tau
            np.clip(commTorque, -20, 20, out=commTorque)
            return list(commTorque[[2, 5, 1, 4, 0, 3]])
        
    
    def run(self):
        if self.newdata:
            torque = Float64MultiArray()
            torque.data = self.compute_controls()
            self.publisher.publish(torque)
            self.get_logger().info("-------------------TORQUE PUBLISHED----------------")
            self.newdata = False
            
    

def main(args=None):
    rclpy.init(args=args)
    node = SimpleLegController()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
